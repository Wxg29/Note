# 六月份面试题总结：

## 6.19：
**1.vue的自定义组件怎么写**
- Vue.directive 注册全局组件 / directives注册局部组件 一般只会用来注册全局组件 v- "指令" 来使用

**2.vuex的使用流程**
- vue的原理：单向数据流
- vuex的作用：项目数据状态的集中管理，复杂组件的数据通信问题
- 先写一个state储存数据 ---> dispatch提交修改数据的请求 ---> 通过actions的commit来触发mutations修改数据(异步修改数据就需要这一步) --->
mutations接收到修改的请求会自动通过Mutate来修改state(同步) ---> 最后store会触发每一个调用它的组件更新


**3.vuex的辅助函数**
- state的辅助函数为： mapState
- actions辅助函数为：mapActions
- mutations辅助函数为：mapMutations
*如何使用*： 1.在当前组件引入Vuex，通过Vuex来调用辅助函数
2.也可以解构引入辅助函数,就可以不用Vuex作为对象来调用属性 例：...Vuex.mapState ---> ...mapState


**4.vue的路由传参的方式**
*- 方式一：*
- router-link进行路由导航（to没加冒号，url地址栏显示参数，:to加了冒号就不显示，获取参数是一样的）
- 传参用<router-link to="/one/login/001"> --- this.$route.params.xxx 获取参数
    - 弊端 ： 刷新页面的时候传递的值会丢失

    *- 方式二：*
    this.$router.push({
    path: `/describe/${id}`,
    })
    需要对应路由配置如下:
    {
    path: '/describe/:id',
    name: 'Describe',
    component: Describe
    }

    this.$route.params.id 来获取
    >如果id后面带了问号 ? 表示参数可传可不传 否则必传

    *- 方式三*
    - 父组件：使用path来匹配路由，然后通过query来传递参数
    这种情况下 query传递的参数会显示在url后面?id=？
    this.$router.push({
    path: '/describe',
    query: {
    id: id
    }
    })
    - 对应路由配置：
    {
    path: '/describe',
    name: 'Describe',
    component: Describe
    }

    this.$route.query.id 来获取
    还可以在对应路由地址后面?拼接，也是query获取


    **5.vue的路由跳转方式**
    - 1. router-link
    - 2. this.$router.push() (函数里面调用)
    - 3. this.$router.replace() (用法同上,push)
    - 4. this.$router.go(n)

    - ps : 区别
    this.$router.push跳转到指定url路径，并想history栈中添加一个记录，点击后退会返回到上一个页面
    this.$router.replace跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面)
    this.$router.go(n)向前或者向后跳转n个页面，n可为正整数或负整数



    **6.js中的隐式转换** ?????????????????????????????
    - = = 两个等号
    - +操作时，数字被隐式转换成字符串，实际上做的是字符串连接操作
    - 除了加法以外的运算操作时，字符串被隐式转换成数字，实际上做的是数值计算
    - .操作调用方法时，隐式地将类型转换成对象
    - if()括号里的表达式部分会被隐式转化为布尔类型进行判别
    附：
    为什么 [] == false ?
    - 类型不同比较时，需要先做类型转换，==比较时有布尔值参与时，需要比较双方均转为数字，[ ]是非原值，需要转换为原值二者才能进行比较，大部分对象转换为原值最后都是调用的toString方法，[] --> toString() —>
    ‘’，当字符串和数字比较时，会把字符串转换为数字，而空字符串转换为数字结果是0，而 0 == 0，所以结果为true

    为什么NaN !== NaN ?
    null == 0 结果为false
    为什么null == undefined 结果为true
    为什么 !![] = true


    **7.px，rem，em的区别**
    - px是相对于长度单位，他是相对于显示器屏幕的分辨率而言的
    - 优缺点：比较稳定和精确，但在浏览器中放大或缩放时会出现页面混乱的情况

    - em是相对长的单位，相对于父元素的字体大小而言
    - 优缺点：em的值并不是固定的，它会继承父级元素的字体大小

    - rem 是css3新增的一个相对单位，rem是相对于html根元素
    - 优缺点：rem是不支援IE8以前的浏览器

    **8.淘宝适配和网易适配**
    - 网易适配： 假设设计稿的rem=100px 屏幕宽度 / 设计稿宽度 = 设备的rem / 假设设计稿的rem
    - 淘宝适配： 把设备宽度 100vw 分成 10等份，假设当前设备的rem 等于 其中的一份，那么1rem = 10vw

    **9.谈谈vue和react**
    - > 明显区别在于数据的定位不同
    - react整体的函数式思想，把组件设计成纯函数，状态和逻辑通过参数传入，单向数据流，推崇结合immutable实现数据的不可变，react在setState之后会重新走渲染的流程
    - vue思想是响应式的，也是基于数据可变的，当数据改变时响应式更新对应得到虚拟dom
    - Vue.js的特性如下：
    　　 1.轻量级的框架
    　　 2.双向数据绑定
    　　 3.指令
    　　 4.插件化

    优点： 1. 简单：官方文档很清晰，比 Angular 简单易学。
    　　　　 2. 快速：异步批处理方式更新 DOM。
    　　　　 3. 组合：用解耦的、可复用的组件组合你的应用程序。

    　 缺点： 1. 新生儿：Vue.js是一个新的项目，没有angular那么成熟。
    　　　　　2. 影响度不是很大：google了一下，有关于Vue.js多样性或者说丰富性少于其他一些有名的库。
    　　　　　3. 不支持IE8：

    - React特性如下：　
    　　　　1.声明式设计：React采用声明范式，可以轻松描述应用。
    　　　　2.高效：React通过对DOM的模拟，最大限度地减少与DOM的交互。
    　　　　3.灵活：React可以与已知的库或框架很好地配合。

    　　优点： 1. 速度快：在UI渲染过程中，React通过在虚拟DOM中的微操作来实现对实际DOM的局部更新。
    　　　　　 2. 跨浏览器兼容：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。
    　　　　　 3. 模块化：为你程序编写独立的模块化UI组件，这样当某个或某些组件出现问题是，可以方便地进行隔离。
    　　　　 　4. 单向数据流：Flux是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。
    　　　　　 5. 同构、纯粹的javascript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。
    　　　　　 6. 兼容性好：比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。

    　　缺点： 1. React本身只是一个V而已，并不是一个完整的框架，所以如果是大型项目想要一套完整的框架的话，基本都需要加上ReactRouter和Flux才能写大型应用。

    **10.登陆注册的逻辑，写在一起还是分开写，同时进行吗**
    **11.vue-cli@3怎么兼容ie**
    **12.H5和css3的新特新**
    - H5新特性：
    语义化标签：header,footer,section,nav,aside,article
    增强型表单：input的多个type
    新增表单元素：datalist,keygen,output
    新增表单元素：placehoder,rquired,min,max
    音频视频：audio，video
    canvas
    拖拽
    地理定位
    本地存储：localStorage - 没有时间限制的数据存储；sessionStorage - 针对一个 session 的数据存储，当用户关闭浏览器窗口后，数据会被删除
    新事件：onresize、ondrag、onscroll、onmousewheel、onerror、onplay、onpause
    bSocket：单个 TCP 连接上进行全双工通讯的协议

    - CSS3 新特性：
    选择器：
    :last-child /* 选择元素最后一个孩子 */
    :first-child /* 选择元素第一个孩子 */
    :nth-child(1) /* 按照第几个孩子给它设置样式 */
    背景和边框：
    background-size：规定背景图片的尺寸（cover：填充；100% 100%：拉伸）
    background-origin：规定背景图片的定位区域
    对于 background-origin 属性，有如下属性
    背景图片可以放置于 content-box、padding-box 或 border-box 区域
    文本效果：
    text-shadow:阴影
    text-justify:规定当 text-align 设置为 “justify” 时所使用的对齐方法
    text-overflow:规定当文本溢出包含元素时发生的事
    text-wrap:规定文本的换行规则
    text-decoration:文本修饰符：overline、line-through、underline 分别是上划线、中划线、下划线
    2D/3D 转换:transform
    translate()：元素从其当前位置移动
    tate()：元素顺时针旋转给定的角度
    scale()：元素的尺寸会增加或减少，
    3D：
    rotateX()：元素围绕其 X 轴以给定的度数进行旋转。transform: rotateX(120deg)
    rotateY()：元素围绕其 Y 轴以给定的度数进行旋转。transform: rotateY(130deg)
    perspective：规定 3D 元素的透视效果
    动画、过渡：animation，transition


    ## 6.22：
    **1.项目该怎么选型框架**
    **2.移动端app要调用原生控件该怎么调用（扫一扫，拍照）**
    **3.你们项目组有多少人**
    **4.说说项目中负责的部分**
    **5.在用户登陆之前第三方接口需要调用用户信息该怎么调用**
    **6.vue的生命周期和钩子函数**
    - beforeCreate :数据还没有监听，没有绑定到vue对象实例，同时也没有挂载对象
    - created:数据已经绑定到了对象实例，但是还没有挂载对象
    - beforeMount:模板已经编译好了，根据数据和模板已经生成了对应的元素对象，将数据对象关联到了对象的 $el属性
    - mounted:将$el的内容挂载到了el,我们能够用方法来获取到el元素下的dom对象，并进 行各种操作
    - beforeupdate:数据更新到dom之前，我们可以看到$el对象已经修改，但是我们页面上dom的数据还没有发生改变
    - updated:改变更新到dom上面，完成更新
    - beforedestroy:实例的销毁，vue实例还是存在的，只是解绑了事件的监听还有watcher对象数据与view的绑定，即数据驱动
    - destroed


    **7.vue的路由守卫**
    全局守卫：beforeEach((to,from,next)=>{})
    后置守卫：afterEach
    全局解析守卫：beforeResolve
    路由独享守卫：beforeEnter
    组内路由守卫：beforeRouteEnter,beforeRouteUpdate,beforeRouteLeave



    **8.项目是怎么搭建的**



    ## 6.23：
    **1.jQuery中的$符号用js代码怎么写**
    **2.简述一下http和https的区别**
    - http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

    - http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

    - http的连接很简单，是无状态的

    - https://blog.csdn.net/qq_38289815/article/details/80969419 (更多详细内容)



    **3.ajax的异步关键字是什么**
    - true

    **4.后端用的什么写的**

    **5.简单描述一下vue**
    - 1.轻量级的框架
    　2.双向数据绑定
    　3.指令
    　4.插件化

    - 优点：1. 简单：官方文档很清晰，比 Angular 简单易学。
    　　　2. 快速：异步批处理方式更新 DOM。
    　　　3. 组合：用解耦的、可复用的组件组合你的应用程序。

    **6.vue的常用指令有哪些**
    - v-bind v-on v-if v-show v-else v-for v-model

    **vue常用的修饰符**
    - once:只能用一次，无论点击几次，执行一次之后都不会再执行
    - stop:阻止事件冒泡，相当于调用了event.stopPropagation()方法
    - lazy:lazy这个修饰符会在光标离开input框才会更新数据
    - trim:输入框过滤首尾的空格
    - number:先输入数字就会限制输入只能是数字，先字符串就相当于没有加number，注意，不是输入框不能输入字符串，是这个数据是数字
    - prevent:阻止默认行为，相当于调用了event.preventDefault()方法，比如表单的提交、a标签的跳转就是默认事件


    ## 6.24：
    **1.margin重叠问题，怪异盒子**
    **2.负的padding不生效**
    **3.假如vue用v-for遍历了四个元素，怎么取到其中一个元素进行操作**
    **4.移动端项目开发完成怎么进行打包，就是图标怎么弄上去的**
    通过
    **5.后端返回数据a后，a又要继续作为参数传给后端怎么传**
    - 第一次的传递参数的回调里面继续传参数

    **6.http和https,https会不会有更大的性能消耗**

    **7.路由守卫的三个参数**
    - to from next

    **8.假如有一个页面有data数据，路由守卫里面怎么获取到这个data，怎么写**

    **9.http的状态码有哪些，有哪些常见的呢**
    - 2开头的状态码
       2xx表示成功处理了请求状态码
               200（成功）服务器已经成功处理了请求通常；

    - 3开头的状态码
       3xx（重定向）表示要完成请求，需要进一步操作，通常这些状态码用来重定向
               304（未修改）自从上次请求后，请求的网页未修改过，服务器返回此响应时不会返回网页内容；

    - 4开头的状态码
       4xx(请求错误)这些状态码表示请求可能出错，妨碍了服务器的处理
             400（错误请求）服务器不理解请求的语法；
             403（禁止）服务器拒绝请求
             404（未找到）服务器找不到请求的网页

    - 5开头的状态码
      5xx(服务器错误)这些状态码表示服务器再尝试处理请求时发生内部错误，这些错误可能是服务器本身错误而不是请求错误
             501（尚未实施）服务器不具备完成请求的功能；
                  例如：服务器无法识别请求方法时可能会返回此代码
             500（服务器内部错误）服务器遇到错误无法完成请求
             502（错误网卡）服务器做为网关或代理，从上游服务器收到无效响应
             503（服务不可用）服务器目前无法使用（由于超载或者停机维护）通常这只是暂时状态
             504（网关超时）服务器做为网关或代理，但是没有及时从上游服务器收到请求
             505（http版本不受支持）服务器不支持请求中所用的http协议版本


    **7.jsonp为什么只能用get方式传递数据**
    - JSONP 是一种请求一段 JS 脚本，把执行这段脚本的结果当做数据的玩法
    - 拼接一个script标签，<script src="http://path/to/server/b?A=a&B=b&callbackFunctionName=myCallback"></script>
    ，从而触发对指定地址的GET请求
    - 那服务器端对这个GET请求进行处理，并返回字符串 "myCallback('response value')"

    **vue里面 $router 和 $route 一样吗，不一样的话区别呢**
    - $router为VueRouter实例，想要导航到不同URL，则使用$router.push方法
    - $route为当前router跳转对象里面可以获取name、path、query、params等